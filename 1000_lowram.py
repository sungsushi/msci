# -*- coding: utf-8 -*-
"""test_lowram.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_E79rH0fgennpLa7HVJ2oUWE9dlG8fVP

# low ram not parallel
"""



import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
import copy 
import os
import time 

def get_intercept(point): # generates 1e4 points and adj list in 3 sec
    return point[0] + point[1]

def gen_graph_adj_2(N, seed=False): 
    # using box space condition
    if seed:
        np.random.seed(seed)
    #generate random coords in (0,1):
    x = np.random.random(N-2)
    y = np.random.random(N-2)

    
    
    unrotpoints = np.array([x,y])
    unrotpoints = unrotpoints[:,get_intercept(unrotpoints).argsort()].T # sort by ascending in causal order

    
    unrotpoints = np.insert(unrotpoints, [0], 0, axis=0) # add the (0,0) node to keep everything causal
    unrotpoints = np.insert(unrotpoints, [len(unrotpoints)], [1, 1], axis=0) # add the sink node
    
    adj = []
    for i in range(N): # need all adjacencies for algorithm but do we really?
        x_cond = (unrotpoints[i][0] - unrotpoints[i+1:][:,0]) < 0
        y_cond = (unrotpoints[i][1] - unrotpoints[i+1:][:,1]) < 0
        indices = np.where((x_cond * y_cond)==True)[0]
        adj.append(list(indices+i+1))

    points = np.array([unrotpoints[:,0]*np.cos(np.pi/4) - unrotpoints[:,1]*np.sin(np.pi/4), 
                     unrotpoints[:,1]*np.sin(np.pi/4) + unrotpoints[:,0]*np.cos(np.pi/4)]).T
    return points, adj

def edge_from_adj(adj):
    edges = []
    for i in range(len(adj)):
        for j in adj[i]:
            edges.append((i, j))
    return edges

def longestpath_s2(adj_list): # origin node is taken to be index (and label) 0.
    N = len(adj_list) # N = no. of nodes in the graph
    
    paths = [[] for i in range(N)]
    paths[0].append(0)  # the path lengths of the shortest from the origin node.
    
    for i in range(N):
        _list = adj_list[i] 
        for j in _list: # consider daughter vertices from node i. 
            plength = len(paths[i]) +1
            if plength > len(paths[j]): # if new path is longer than existing path
                paths[j] = paths[i] + [j] # replace old path with the new path
    return paths # prints an array of longest paths  whose index corresponds to node label.



def greedy_path(adj):
    # adj is the adjacency list of the network. 
    # points is the coordinates of those nodes
    path = [0] #start with node zero
    current_node = 0
    while current_node != len(adj)-1:
        next_node = adj[current_node][0] # because we have already time sorted it, 
                                    #0th element should be the closest in time. 
        path.append(next_node)
        current_node = next_node
    return path


def random_path(adj_list, seed=None):
    if seed:
        np.random.seed(seed)
    N = len(adj_list)
    i = 0
    path = [0]
    while i < N-1:
        #print(i)
        j = np.random.choice(adj_list[i])
        path.append(j)
        i = j
    return path

t_0 = time.time()

#array_index = int(os.environ['PBS_ARRAY_INDEX']) # 1,2
Ns = [int(1e1), int(5e1), int(1e2), int(5e2), int(1e3), int(5e3), int(1e4)]
#Ns = [int(10)]
#many_points = []
#many_adjs = []
realisations = int(1000)

longest_path_points = []
greedy_path_points = []
random_path_points = []

for j in Ns:
    N_l_coords = []
    N_g_coords = []
    N_r_coords = []
    for i in range(realisations):
        points, adj = gen_graph_adj_2(j, seed= int(i + 1))
        #Ns_points.append(points)

        lp = longestpath_s2(adj)[-1] 
        gp = greedy_path(adj)
        rp = random_path(adj, seed=int(i+1))


        N_l_coords.append(points[lp])
        N_g_coords.append(points[gp])
        N_r_coords.append(points[rp])

    longest_path_points.append(N_l_coords)    
    greedy_path_points.append(N_g_coords)    
    random_path_points.append(N_r_coords)    

many_paths = np.array([Ns, realisations, longest_path_points, greedy_path_points, random_path_points], dtype=object)
file_name = f"{realisations}_paths.npy"
np.save(file_name, many_paths, allow_pickle=True)

print('time taken = ', time.time() - t_0)

